# Understanding Design Patterns

## Q: what design patterns have you used?

Across several languages, I have used approximately half of the design patterns we have learned so far.

- **Behavioral** - Command, Iterator, Memento, Observer, State, and Vistitor
- **Creational** - Factory, Abstract Factory, Builder, and Singleton
- **Structural** - Adapter, Decorator, and Facade

## Q: what design patterns are important and why?

I think that all the design patterns we have learned so far should be considered important. New business use-cases provide new opportunities to consider how an application (or suite of applications) should be designed, and how each subsystem should interact with one another. Design patterns are another tool in our software engineering toolbox, and more than one tool (or design pattern) can be used to solve the same problem - it is a matter of evaluating the existing systems and determining which pattern might suit the current application best.

## Q: what design patterns do you think are trivial and why?

I don't think we have learned about a design pattern I would consider trivial, but I do think some tend to be more practical within my experience as a full stack software engineer to this point. For example, I tend to work in Angular engineering reusable components used in a web application, and implementing a number of these design patterns would be quite a bit more effort than using the Angular paradigms and syntactic sugar provided by the framework, or potentially more work than leveraging an existing library that processes data with these design patterns hidden by a facade. However, I use adaptations of these design patterns on a daily basis either through the applications I work on directly or with the libraries we leverage within it.

But as an honorable mention, I think the chain of responsibility can be incredibly cumbersome to deal with if not implemented properly.